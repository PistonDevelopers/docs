var searchIndex = {};
searchIndex["y4m"] = {"doc":"YUV4MPEG2 (.y4m) Encoder/Decoder","items":[[3,"Ratio","y4m","Simple ratio structure since stdlib lacks one.",null,null],[12,"num","","Numerator.",0,null],[12,"den","","Denominator.",0,null],[3,"Decoder","","YUV4MPEG2 decoder.",null,null],[3,"Frame","","A single frame.",null,null],[3,"EncoderBuilder","","Encoder builder. Allows to set y4m file parameters using builder pattern.",null,null],[3,"Encoder","","YUV4MPEG2 encoder.",null,null],[4,"Error","","Both encoding and decoding errors.",null,null],[13,"EOF","","End of the file. Technically not an error, but it's easier to process that way.",1,null],[13,"BadInput","","Bad input parameters provided.",1,null],[13,"UnknownColorspace","","Unknown colorspace (possibly just unimplemented)",1,null],[13,"ParseError","","Error while parsing the file/frame header.",1,null],[13,"IoError","","Error while reading/writing the file.",1,null],[4,"Colorspace","","Colorspace. It's a color model in fact, but let's conform to the spec. NOTE: Only 8-bit and 10-bit formats are currently supported.",null,null],[13,"Cmono","","Grayscale only, 8-bit.",2,null],[13,"C420","","4:2:0 with coincident chroma planes, 8-bit.",2,null],[13,"C420p10","","4:2:0 with coincident chroma planes, 10-bit.",2,null],[13,"C420jpeg","","4:2:0 with biaxially-displaced chroma planes, 8-bit.",2,null],[13,"C420paldv","","4:2:0 with vertically-displaced chroma planes, 8-bit.",2,null],[13,"C420mpeg2","","Found in some files. Same as `C420`.",2,null],[13,"C422","","4:2:2, 8-bit.",2,null],[13,"C422p10","","4:2:2, 10-bit.",2,null],[13,"C444","","4:4:4, 8-bit.",2,null],[13,"C444p10","","4:4:4, 10-bit.",2,null],[5,"decode","","Create a new decoder instance. Alias for `Decoder::new`.",null,{"inputs":[{"name":"r"}],"output":{"generics":["decoder","error"],"name":"result"}}],[5,"encode","","Create a new encoder builder. Alias for `EncoderBuilder::new`.",null,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"ratio"}],"output":{"name":"encoderbuilder"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",1,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",1,{"inputs":[{"name":"parseinterror"}],"output":{"name":"error"}}],[11,"from","","",1,{"inputs":[{"name":"utf8error"}],"output":{"name":"error"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"ratio"}}],[11,"new","","Create a new ratio.",0,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"ratio"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"colorspace"}}],[11,"get_bit_depth","","Return the bit depth per sample",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_bytes_per_sample","","Return the number of bytes in a sample",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"new","","Create a new decoder instance.",3,{"inputs":[{"name":"r"}],"output":{"generics":["decoder","error"],"name":"result"}}],[11,"read_frame","","Iterate over frames, without extra heap allocations. End of input is indicated by `Error::EOF`.",3,{"inputs":[{"name":"self"}],"output":{"generics":["frame","error"],"name":"result"}}],[11,"get_width","","Return file width.",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_height","","Return file height.",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_framerate","","Return file framerate.",3,{"inputs":[{"name":"self"}],"output":{"name":"ratio"}}],[11,"get_colorspace","","Return file colorspace.",3,{"inputs":[{"name":"self"}],"output":{"name":"colorspace"}}],[11,"get_raw_params","","Return file raw parameters.",3,null],[11,"get_bit_depth","","Return the bit depth per sample",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_bytes_per_sample","","Return the number of bytes in a sample",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new frame with optional parameters. No heap allocations are made.",4,null],[11,"get_y_plane","","Return Y (first) plane.",4,null],[11,"get_u_plane","","Return U (second) plane. Empty in case of grayscale.",4,null],[11,"get_v_plane","","Return V (third) plane. Empty in case of grayscale.",4,null],[11,"get_raw_params","","Return frame raw parameters if any.",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new encoder builder.",5,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"ratio"}],"output":{"name":"encoderbuilder"}}],[11,"with_colorspace","","Specify file colorspace.",5,{"inputs":[{"name":"self"},{"name":"colorspace"}],"output":{"name":"self"}}],[11,"write_header","","Write header to the stream and create encoder instance.",5,{"inputs":[{"name":"self"},{"name":"w"}],"output":{"generics":["encoder","error"],"name":"result"}}],[11,"write_frame","","Write next frame to the stream.",6,{"inputs":[{"name":"self"},{"name":"frame"}],"output":{"generics":["error"],"name":"result"}}]],"paths":[[3,"Ratio"],[4,"Error"],[4,"Colorspace"],[3,"Decoder"],[3,"Frame"],[3,"EncoderBuilder"],[3,"Encoder"]]};
initSearch(searchIndex);
