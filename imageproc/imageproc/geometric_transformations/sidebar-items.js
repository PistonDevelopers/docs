initSidebarItems({"enum":[["Interpolation","How to handle pixels whose pre-image lies between input pixels."]],"fn":[["rotate","Rotate an image clockwise about provided center by theta radians. The output image has the same dimensions as the input. Output pixels whose pre-image lies outside the input image are set to `default`."],["rotate_about_center","Rotate an image clockwise about image center. The output image has the same dimensions as the input. Output pixels whose pre-image lies outside the input image are set to `default`."],["translate","Translates the input image by t. Note that image coordinates increase from top left to bottom right. Output pixels whose pre-image are not in the input image are set to the boundary pixel in the input image nearest to their pre-image."],["warp","Performs projective transformation to an image. Allocates an output image with same dimensions as the input image. Output pixels outside the input image are set to `default`. Projection `homography` defines a mapping from coordinates in the `image` image to coordinates of the output image."],["warp_into","Performs projective transformation `homography` mapping pixels from `image` into `&mut output`. Projection `homograpy` defines coordinate mapping from `image` to `out`."],["warp_into_with","Warp image with custom function. This enables the user to define a custom mapping such as a wave pattern: ``` use image::{ImageBuffer, Luma}; use imageproc::utils::gray_bench_image; use imageproc::geometric_transformations::*;"],["warp_with","Transforms input `image` into output image of the same size. Fm `mapping` is the coordinate mapping function, mapping coordinates from out to in."]],"struct":[["Projection","A 2d Projective transformation, stored as a row major 3x3 matrix. Transformations combine by multiplication."]]});