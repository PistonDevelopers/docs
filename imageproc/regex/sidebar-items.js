initSidebarItems({"enum":[["CaptureNames","Yields the names of all possible captures. `None` indicates an unnamed capture; the first element (capture 0, the whole matched region) is always unnamed.`'r` is the lifetime of the compiled expression."],["Error","An error that occurred during parsing or compiling a regular expression."],["Regex","A compiled regular expressionIt is represented as either a sequence of bytecode instructions (dynamic) or as a specialized Rust function (native). It can be used to search, split or replace text. All searching is done with an implicit `.*?` at the beginning and end of an expression. To force an expression to match the whole string (or a prefix or a suffix), you must use an anchor like `^` or `$` (or `\\A` and `\\z`).While this crate will handle Unicode strings (whether in the regular expression or in the search text), all positions returned are **byte indices**. Every byte index is guaranteed to be at a Unicode code point boundary.The lifetimes `'r` and `'t` in this crate correspond to the lifetime of a compiled regular expression and text to search, respectively.The only methods that allocate new strings are the string replacement methods. All other methods (searching and splitting) return borrowed pointers into the string given.ExamplesFind the location of a US phone number:Using the `std::str::StrExt` methods with `Regex`**Note**: This section requires that this crate is currently compiled with           the `pattern` Cargo feature enabled.Since `Regex` implements `Pattern`, you can use regexes with methods defined on `std::str::StrExt`. For example, `is_match`, `find`, `find_iter` and `split` can be replaced with `StrExt::contains`, `StrExt::find`, `StrExt::match_indices` and `StrExt::split`.Here are some examples:"]],"fn":[["is_match","Tests if the given regular expression matches somewhere in the text given.If there was a problem compiling the regular expression, an error is returned.To find submatches, split or replace text, you'll need to compile an expression first."],["quote","Escapes all regular expression meta characters in `text`.The string returned may be safely used as a literal in a regular expression."]],"struct":[["Captures","Captures represents a group of captured strings for a single match.The 0th capture always corresponds to the entire match. Each subsequent index corresponds to the next capture group in the regex. If a capture group is named, then the matched string is *also* available via the `name` method. (Note that the 0th capture is always unnamed and so must be accessed with the `at` method.)Positions returned from a capture group are always byte indices.`'t` is the lifetime of the matched text."],["FindCaptures","An iterator that yields all non-overlapping capture groups matching a particular regular expression.The iterator stops when no more matches can be found.`'r` is the lifetime of the compiled expression and `'t` is the lifetime of the matched string."],["FindMatches","An iterator over all non-overlapping matches for a particular string.The iterator yields a tuple of integers corresponding to the start and end of the match. The indices are byte offsets. The iterator stops when no more matches can be found.`'r` is the lifetime of the compiled expression and `'t` is the lifetime of the matched string."],["NoExpand","NoExpand indicates literal string replacement.It can be used with `replace` and `replace_all` to do a literal string replacement without expanding `$name` to their corresponding capture groups.`'r` is the lifetime of the literal text."],["RegexSet","Match multiple (possibly overlapping) regular expressions in a single scan.A regex set corresponds to the union of two or more regular expressions. That is, a regex set will match text where at least one of its constituent regular expressions matches. A regex set as its formulated here provides a touch more power: it will also report *which* regular expressions in the set match. Indeed, this is the key difference between regex sets and a single `Regex` with many alternates, since only one alternate can match at a time.For example, consider regular expressions to match email addresses and domains: `[a-z]+@[a-z]+.(com|org|net)` and `[a-z]+.(com|org|net)`. If a regex set is constructed from those regexes, then searching the text `foo@example.com` will report both regexes as matching. Of course, one could accomplish this by compiling each regex on its own and doing two searches over the text. The key advantage of using a regex set is that it will report the matching regexes using a *single pass through the text*. If one has hundreds or thousands of regexes to match repeatedly (like a URL router for a complex web application or a user agent matcher), then a regex set can realize huge performance gains.ExampleThis shows how the above two regexes (for matching email addresses and domains) might work:Note that it would be possible to adapt the above example to using `Regex` with an expression like:After a match, one could then inspect the capture groups to figure out which alternates matched. The problem is that it is hard to make this approach scale when there are many regexes since the overlap between each alternate isn't always obvious to reason about.LimitationsRegex sets are limited to answering the following two questions:Does any regex in the set match? If so, which regexes in the set match? As with the main `Regex` type, it is cheaper to ask (1) instead of (2) since the matching engines can stop after the first match is found.Other features like finding the location of successive matches or their sub-captures aren't supported. If you need this functionality, the recommended approach is to compile each regex in the set independently and selectively match them based on which regexes in the set matched.PerformanceA `RegexSet` has the same performance characteristics as `Regex`. Namely, search takes `O(mn)` time, where `m` is proportional to the size of the regex set and `n` is proportional to the length of the search text."],["RegexSplits","Yields all substrings delimited by a regular expression match.`'r` is the lifetime of the compiled expression and `'t` is the lifetime of the string being split."],["RegexSplitsN","Yields at most `N` substrings delimited by a regular expression match.The last substring will be whatever remains after splitting.`'r` is the lifetime of the compiled expression and `'t` is the lifetime of the string being split."],["SetMatches","A set of matches returned by a regex set."],["SetMatchesIntoIter","An owned iterator over the set of matches from a regex set."],["SetMatchesIter","A borrowed iterator over the set of matches from a regex set.The lifetime `'a` refers to the lifetime of a `SetMatches` value."],["SubCaptures","An iterator over capture groups for a particular match of a regular expression.`'c` is the lifetime of the captures."],["SubCapturesNamed","An Iterator over named capture groups as a tuple with the group name and the value.`'c` is the lifetime of the captures."],["SubCapturesPos","An iterator over capture group positions for a particular match of a regular expression.Positions are byte indices in terms of the original string matched.`'c` is the lifetime of the captures."]],"trait":[["Replacer","Replacer describes types that can be used to replace matches in a string."]]});