initSidebarItems({"enum":[["CaptureNames","Yields the names of all possible captures. `None` indicates an unnamed capture; the first element (capture 0, the whole matched region) is always unnamed.`'r` is the lifetime of the compiled expression."],["Error","An error that occurred during parsing or compiling a regular expression."],["Regex","A compiled regular expressionIt is represented as either a sequence of bytecode instructions (dynamic) or as a specialized Rust function (native). It can be used to search, split or replace text. All searching is done with an implicit `.*?` at the beginning and end of an expression. To force an expression to match the whole string (or a prefix or a suffix), you must use an anchor like `^` or `$` (or `\\A` and `\\z`).While this crate will handle Unicode strings (whether in the regular expression or in the search text), all positions returned are **byte indices**. Every byte index is guaranteed to be at a Unicode code point boundary.The lifetimes `'r` and `'t` in this crate correspond to the lifetime of a compiled regular expression and text to search, respectively.The only methods that allocate new strings are the string replacement methods. All other methods (searching and splitting) return borrowed pointers into the string given.ExamplesFind the location of a US phone number:Using the `std::str::StrExt` methods with `Regex`**Note**: This section requires that this crate is currently compiled with           the `pattern` Cargo feature enabled.Since `Regex` implements `Pattern`, you can use regexes with methods defined on `std::str::StrExt`. For example, `is_match`, `find`, `find_iter` and `split` can be replaced with `StrExt::contains`, `StrExt::find`, `StrExt::match_indices` and `StrExt::split`.Here are some examples:"]],"fn":[["is_match","Tests if the given regular expression matches somewhere in the text given.If there was a problem compiling the regular expression, an error is returned.To find submatches, split or replace text, you'll need to compile an expression first."],["quote","Escapes all regular expression meta characters in `text`.The string returned may be safely used as a literal in a regular expression."]],"struct":[["Captures","Captures represents a group of captured strings for a single match.The 0th capture always corresponds to the entire match. Each subsequent index corresponds to the next capture group in the regex. If a capture group is named, then the matched string is *also* available via the `name` method. (Note that the 0th capture is always unnamed and so must be accessed with the `at` method.)Positions returned from a capture group are always byte indices.`'t` is the lifetime of the matched text."],["FindCaptures","An iterator that yields all non-overlapping capture groups matching a particular regular expression.The iterator stops when no more matches can be found.`'r` is the lifetime of the compiled expression and `'t` is the lifetime of the matched string."],["FindMatches","An iterator over all non-overlapping matches for a particular string.The iterator yields a tuple of integers corresponding to the start and end of the match. The indices are byte offsets. The iterator stops when no more matches can be found.`'r` is the lifetime of the compiled expression and `'t` is the lifetime of the matched string."],["NoExpand","NoExpand indicates literal string replacement.It can be used with `replace` and `replace_all` to do a literal string replacement without expanding `$name` to their corresponding capture groups.`'r` is the lifetime of the literal text."],["RegexSplits","Yields all substrings delimited by a regular expression match.`'r` is the lifetime of the compiled expression and `'t` is the lifetime of the string being split."],["RegexSplitsN","Yields at most `N` substrings delimited by a regular expression match.The last substring will be whatever remains after splitting.`'r` is the lifetime of the compiled expression and `'t` is the lifetime of the string being split."],["SubCaptures","An iterator over capture groups for a particular match of a regular expression.`'t` is the lifetime of the matched text."],["SubCapturesNamed","An Iterator over named capture groups as a tuple with the group name and the value.`'t` is the lifetime of the matched text."],["SubCapturesPos","An iterator over capture group positions for a particular match of a regular expression.Positions are byte indices in terms of the original string matched.`'t` is the lifetime of the matched text."]],"trait":[["Replacer","Replacer describes types that can be used to replace matches in a string."]]});