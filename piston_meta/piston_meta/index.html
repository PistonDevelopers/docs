<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `piston_meta` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, piston_meta">

    <title>piston_meta - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc mod">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'>Crate piston_meta</p><div class="block items"><ul><li><a href="#reexports">Reexports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'piston_meta', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Crate <a class="mod" href=''>piston_meta</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/piston_meta/lib.rs.html#1-269' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>A DSL parsing library for human readable text documents</p>

<p>Piston-Meta makes it easy to write parsers for human readable text documents.
It can be used for language design, custom formats and data driven development.</p>

<p>Meta parsing is a development technique that goes back to the first modern computer.
The idea is to turn pieces of a computer program into a programmable pipeline,
and thereby accelerating development.
An important, but surprisingly reusable part across projects, is the concept of generating
structured data from text, since text is easy to modify and reason about.</p>

<p>Most programs that work with text uses the following pipeline:</p>

<pre class="rust rust-example-rendered">
<span class="ident">f</span> : <span class="ident">text</span> <span class="op">-&gt;</span> <span class="ident">data</span></pre>

<p>The problem with this approach is that <code>f</code> changes from project to project,
and the task of transforming text into a data structure can get very complex.
For example, to create a parser for the syntax of a programming language,
one might need several thousands lines of code.
This slows down development and increases the chance of making errors.</p>

<p>Meta parsing is a technique where <code>f</code> gets splitted into two steps:</p>

<pre class="rust rust-example-rendered">
<span class="ident">f</span> <span class="op">&lt;=</span><span class="op">&gt;</span> <span class="ident">f2</span> . <span class="ident">f1</span>
<span class="ident">f1</span> : <span class="ident">text</span> <span class="op">-&gt;</span> <span class="ident">meta</span> <span class="ident">data</span>
<span class="ident">f2</span> : <span class="ident">meta</span> <span class="ident">data</span> <span class="op">-&gt;</span> <span class="ident">data</span></pre>

<p>The first step <code>f1</code> takes text and converts it into a meta data.
A DSL (Domain Specific Language) is used to describe how this transformation happens.
The second step <code>f2</code> converts meta data into data, and this is often written as code.</p>

<h3 id='rules' class='section-header'><a href='#rules'>Rules</a></h3>
<p>The meta language is used to describe how to read other documents.
First you define some strings to reuse, then some node rules.
The last node is used to read the entire document.</p>

<p><code>20 document = [.l(string:&quot;string&quot;) .l(node:&quot;node&quot;) .w?]</code></p>

<p>Strings starts with underscore and can be reused among the rules:</p>

<p><code>_opt: &quot;optional&quot;</code></p>

<p>Nodes start with a number that gets multiplied with 1000 and used as debug id.
If you get an error <code>#4003</code>, then it was caused by a rule in the node starting with 4.</p>

<table>
<thead>
<tr>
<th>Rule</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>.l(rule)</td>
<td>Separates sub rule with lines.</td>
</tr>
<tr>
<td>.r?(rule)</td>
<td>Repeats sub rule until it fails, allows zero repetitions.</td>
</tr>
<tr>
<td>.r!(rule)</td>
<td>Repeats sub rule until it fails, requires at least one repetition.</td>
</tr>
<tr>
<td>...any_characters?:name</td>
<td>Reads a string until any characters, allows zero characters. Name is optional.</td>
</tr>
<tr>
<td>...any_characters!:name</td>
<td>Reads a string until any characters, requires at least one character. Name is optional.</td>
</tr>
<tr>
<td>..any_characters?:name</td>
<td>Reads a string until any characters or whitespace, allows zero characters. Name is optional.</td>
</tr>
<tr>
<td>..any_characters!:name</td>
<td>Reads a string until any characters or whitespace, requires at least one character. Name is optional.</td>
</tr>
<tr>
<td>.w?</td>
<td>Reads whitespace. The whitespace is optional.</td>
</tr>
<tr>
<td>.w!</td>
<td>Reads whitespace. The whitespace is required.</td>
</tr>
<tr>
<td>?rule</td>
<td>Makes the rule optional.</td>
</tr>
<tr>
<td>&quot;token&quot;:name</td>
<td>Expects a token, sets name to <code>true</code>. Name is optional.</td>
</tr>
<tr>
<td>&quot;token&quot;:!name</td>
<td>Expects a token, sets name to <code>false</code>. Name is required.</td>
</tr>
<tr>
<td>!&quot;token&quot;:name</td>
<td>Fails if token is read, sets name to <code>true</code> if it is not read. Name is optional.</td>
</tr>
<tr>
<td>!&quot;token&quot;:!name</td>
<td>Fails if token is read, sets name to <code>false</code> if it is not read. Name is required.</td>
</tr>
<tr>
<td>!rule</td>
<td>Fails if rule is read.</td>
</tr>
<tr>
<td>.s?(by_rule rule)</td>
<td>Separates rule by another rule, allows zero repetitions.</td>
</tr>
<tr>
<td>.s!(by_rule rule)</td>
<td>Separates rule by another rule, requires at least one repetition.</td>
</tr>
<tr>
<td>.s?.(by_rule rule)</td>
<td>Separates rule by another rule, allows trailing.</td>
</tr>
<tr>
<td>{rules}</td>
<td>Selects a rule. Tries the first rule, then the second etc. Rules are separated by whitespace.</td>
</tr>
<tr>
<td>[rules]</td>
<td>A sequence of rules. Rules are separated by whitespace.</td>
</tr>
<tr>
<td>node</td>
<td>Uses a node without a name. The read data is put in the current node.</td>
</tr>
<tr>
<td>node:name</td>
<td>Uses a node with a name. The read data is put in a new node with the name.</td>
</tr>
<tr>
<td>.t?:name</td>
<td>Reads a JSON string with a name. The string can be empty. Name is optional.</td>
</tr>
<tr>
<td>.t!:name</td>
<td>Reads a JSON string with a name. The string can not be empty. Name is optional.</td>
</tr>
<tr>
<td>.$:name</td>
<td>Reads a number with a name. The name is optional.</td>
</tr>
<tr>
<td>.$_:name</td>
<td>Reads a number with underscore as visible separator, for example <code>10_000</code>. The name is optional.</td>
</tr>
</tbody>
</table>

<h3 id='hello-world-in-piston-meta' class='section-header'><a href='#hello-world-in-piston-meta'>&quot;Hello world&quot; in Piston-Meta</a></h3>
<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">piston_meta</span>;

<span class="kw">use</span> <span class="ident">piston_meta</span>::<span class="kw-2">*</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">r#&quot;hi James!&quot;#</span>;
    <span class="kw">let</span> <span class="ident">rules</span> <span class="op">=</span> <span class="string">r#&quot;
        1 say_hi = [&quot;hi&quot; .w? {&quot;James&quot;:&quot;james&quot; &quot;Peter&quot;:&quot;peter&quot;} &quot;!&quot;]
        2 document = say_hi
    &quot;#</span>;
    <span class="comment">// Parse rules with meta language and convert to rules for parsing text.</span>
    <span class="kw">let</span> <span class="ident">rules</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">syntax_errstr</span>(<span class="ident">rules</span>) {
        <span class="prelude-val">Err</span>(<span class="ident">err</span>) <span class="op">=&gt;</span> {
            <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">err</span>);
            <span class="kw">return</span>;
        }
        <span class="prelude-val">Ok</span>(<span class="ident">rules</span>) <span class="op">=&gt;</span> <span class="ident">rules</span>
    };
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
    <span class="kw">match</span> <span class="ident">parse_errstr</span>(<span class="kw-2">&amp;</span><span class="ident">rules</span>, <span class="ident">text</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">data</span>) {
        <span class="prelude-val">Err</span>(<span class="ident">err</span>) <span class="op">=&gt;</span> {
            <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">err</span>);
            <span class="kw">return</span>;
        }
        <span class="prelude-val">Ok</span>(()) <span class="op">=&gt;</span> {}
    };
    <span class="ident">json</span>::<span class="ident">print</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>);
}</pre>

<h3 id='bootstrapping' class='section-header'><a href='#bootstrapping'>Bootstrapping</a></h3>
<p>When the meta language changes, bootstrapping is used to host old meta syntax in the new meta syntax. Here is how it works:</p>

<ol>
<li>Piston-Meta contains composable rules that can parse many human readable text formats.</li>
<li>Piston-Meta knows how to parse and convert to its own rules, known as &quot;bootstrapping&quot;.</li>
<li>Therefore, you can tell Piston-Meta how to parse other text formats using a meta language!</li>
<li>Including the text format describing how to parse its own syntax, which generates equivalent rules to the ones hard coded in Rust.</li>
<li>New versions of the meta language can describe older versions to keep backwards compatibility, by changing the self syntax slightly, so it can read an older version of itself.</li>
</ol>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Reexports</a></h2>
<table><tr><td><code>pub use meta_rules::<a class="fn" href="../piston_meta/meta_rules/fn.parse.html" title="fn piston_meta::meta_rules::parse">parse</a>;</code></td></tr><tr><td><code>pub use meta_rules::<a class="fn" href="../piston_meta/meta_rules/fn.parse_errstr.html" title="fn piston_meta::meta_rules::parse_errstr">parse_errstr</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="mod" href="bootstrap/index.html"
                                  title='mod piston_meta::bootstrap'>bootstrap</a></td>
                           <td class='docblock-short'>
                                <p>Bootstrapping meta rules for changing documents at runtime</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="json/index.html"
                                  title='mod piston_meta::json'>json</a></td>
                           <td class='docblock-short'>
                                <p>Write meta data as JSON.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="meta_rules/index.html"
                                  title='mod piston_meta::meta_rules'>meta_rules</a></td>
                           <td class='docblock-short'>
                                <p>Building blocks for meta rules.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="tokenizer/index.html"
                                  title='mod piston_meta::tokenizer'>tokenizer</a></td>
                           <td class='docblock-short'>
                                <p>Tracking tokenizer state.</p>
                           </td>
                       </tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ParseErrorHandler.html"
                                  title='struct piston_meta::ParseErrorHandler'>ParseErrorHandler</a></td>
                           <td class='docblock-short'>
                                <p>Reports error.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Syntax.html"
                                  title='struct piston_meta::Syntax'>Syntax</a></td>
                           <td class='docblock-short'>
                                <p>Stores syntax.</p>
                           </td>
                       </tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.MetaData.html"
                                  title='enum piston_meta::MetaData'>MetaData</a></td>
                           <td class='docblock-short'>
                                <p>Represents meta data.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.ParseError.html"
                                  title='enum piston_meta::ParseError'>ParseError</a></td>
                           <td class='docblock-short'>
                                <p>Errors reporting expected values.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Rule.html"
                                  title='enum piston_meta::Rule'>Rule</a></td>
                           <td class='docblock-short'>
                                <p>A rule describes how some section of a document should be parsed.</p>
                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.load_syntax_data.html"
                                  title='fn piston_meta::load_syntax_data'>load_syntax_data</a></td>
                           <td class='docblock-short'>
                                <p>Convenience method for loading data, using the meta language.
Panics if there is an error, and writes error message to
standard error output.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.stderr_unwrap.html"
                                  title='fn piston_meta::stderr_unwrap'>stderr_unwrap</a></td>
                           <td class='docblock-short'>
                                <p>When an error happens, reports to standard error and then panics.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.syntax.html"
                                  title='fn piston_meta::syntax'>syntax</a></td>
                           <td class='docblock-short'>
                                <p>Reads syntax from text.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.syntax_errstr.html"
                                  title='fn piston_meta::syntax_errstr'>syntax_errstr</a></td>
                           <td class='docblock-short'>
                                <p>Reads syntax from text, formatting the error as <code>String</code>.</p>
                           </td>
                       </tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="type" href="type.DebugId.html"
                                  title='type piston_meta::DebugId'>DebugId</a></td>
                           <td class='docblock-short'>
                                <p>The type of debug id used to track down errors in rules.</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "piston_meta";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>