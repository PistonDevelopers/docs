var searchIndex = {};
searchIndex["piston_meta"] = {"doc":"A DSL parsing library for human readable text documents","items":[[3,"ParseErrorHandler","piston_meta","Reports error.",null,null],[3,"Syntax","","Stores syntax.",null,null],[12,"rules","","Rule data.",0,null],[12,"names","","Name of rules.",0,null],[4,"ParseError","","Errors reporting expected values.",null,null],[13,"ExpectedWhitespace","","Whitespace is required.",1,null],[13,"ExpectedNewLine","","New line is required.",1,null],[13,"ExpectedSomething","","Something is required.",1,null],[13,"ExpectedNumber","","Expected number.",1,null],[13,"ParseNumberError","","Error when parsing float.",1,null],[13,"ExpectedText","","Expected text.",1,null],[13,"EmptyTextNotAllowed","","Empty text not allowed.",1,null],[13,"ParseStringError","","Invalid string format.",1,null],[13,"ExpectedTag","","Expected token.",1,null],[13,"DidNotExpectTag","","Did not expected token.",1,null],[13,"InvalidRule","","An invalid rule.",1,null],[13,"NoRules","","No rules are specified.",1,null],[13,"ExpectedEnd","","Expected to reach the end.",1,null],[13,"Conversion","","Conversion error.",1,null],[4,"Rule","","A rule describes how some section of a document should be parsed.",null,null],[13,"Whitespace","","Read whitespace.",2,null],[13,"Tag","","Match against a tag.",2,null],[13,"UntilAny","","Reads until any character.",2,null],[13,"UntilAnyOrWhitespace","","Read until any character or whitespace.",2,null],[13,"Text","","Read text.",2,null],[13,"Number","","Read number.",2,null],[13,"Select","","Select one of the sub rules. If the first one does not succeed, try another and so on. If all sub rules fail, then the rule fails.",2,null],[13,"Sequence","","Run each sub rule in sequence. If any sub rule fails, the rule fails.",2,null],[13,"SeparateBy","","Repeat rule separated by another rule.",2,null],[13,"Repeat","","Repeat rule.",2,null],[13,"Lines","","Repeat rule separated by one or more lines.",2,null],[13,"Node","","Read node.",2,null],[13,"Optional","","Read optional.",2,null],[13,"Not","","Read not.",2,null],[4,"MetaData","","Represents meta data.",null,null],[13,"StartNode","","Starts node.",3,null],[13,"EndNode","","Ends node.",3,null],[13,"Bool","","Sets bool property.",3,null],[13,"F64","","Sets f64 property.",3,null],[13,"String","","Sets string property.",3,null],[5,"stderr_unwrap","","When an error happens, reports to standard error and then panics.",null,{"inputs":[{"name":"str"},{"name":"result"}],"output":{"name":"t"}}],[5,"syntax","","Reads syntax from text.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"syntax_errstr","","Reads syntax from text, formatting the error as `String`.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"load_syntax_data","","Convenience method for loading data, using the meta language. Panics if there is an error, and writes error message to standard error output.",null,{"inputs":[{"name":"a"},{"name":"b"}],"output":{"name":"vec"}}],[0,"bootstrap","","Bootstrapping meta rules for changing documents at runtime",null,null],[3,"Convert","piston_meta::bootstrap","Stores state when converting from meta data.",null,null],[5,"rules","","Returns rules for parsing meta rules.",null,{"inputs":[],"output":{"name":"syntax"}}],[5,"convert","","Converts meta data to rules.",null,null],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"convert"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `Convert`.",4,null],[11,"remaining_data_len","","Returns the length of remaining data.",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"subtract","","Returns the difference in offset.",4,{"inputs":[{"name":"self"},{"name":"convert"}],"output":{"name":"range"}}],[11,"source","","Returns the subtracted range in source (union of meta data ranges).",4,{"inputs":[{"name":"self"},{"name":"convert"}],"output":{"name":"option"}}],[11,"update","","Updates with parsed range.",4,{"inputs":[{"name":"self"},{"name":"range"}],"output":null}],[11,"start_node","","Reads start node.",4,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"end_node","","Reads end node.",4,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"ignore","","Ignores next item. If this is the start of a node, it ignores all items to the end node.",4,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"meta_string","","Reads string.",4,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"meta_f64","","Reads f64.",4,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"meta_bool","","Reads bool.",4,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[0,"json","piston_meta","Write meta data as JSON.",null,null],[5,"write","piston_meta::json","Writes meta data as JSON.",null,null],[5,"write_string","","Writes a JSON string.",null,{"inputs":[{"name":"w"},{"name":"str"}],"output":{"name":"result"}}],[5,"print","","Prints meta data.",null,null],[0,"meta_rules","piston_meta","Building blocks for meta rules.",null,null],[3,"Lines","piston_meta::meta_rules","Stores information about lines.",null,null],[12,"rule","","The rule to read lines. This can be a multi-line rule.",5,null],[12,"debug_id","","A debug id to track down the rule generating an error.",5,null],[3,"Node","","A node reference.",null,null],[12,"name","","Name of rule.",6,null],[12,"property","","The property to set.",6,null],[12,"debug_id","","A debug id to track down the rule generating an error.",6,null],[12,"index","","The index to the rule reference.",6,null],[3,"Not","","Stores information about not.",null,null],[12,"rule","","The not rule.",7,null],[12,"debug_id","","A debug id to track down the rule generating an error.",7,null],[3,"Number","","Contains information about number.",null,null],[12,"property","","The property to set.",8,null],[12,"debug_id","","A debug id to track down the rule generating an error.",8,null],[12,"allow_underscore","","Whether underscore is allowed as visible separator.",8,null],[3,"Optional","","Stores information about optional.",null,null],[12,"rule","","The optional rule.",9,null],[12,"debug_id","","A debug id to track down the rule generating an error.",9,null],[3,"Repeat","","Stores inforamtion about separated by.",null,null],[12,"rule","","The rule to separate.",10,null],[12,"optional","","Whether the rule must occur at least once.",10,null],[12,"debug_id","","A debug id to track down the rule generating an error.",10,null],[3,"Select","","Stores information about select.",null,null],[12,"args","","The rules to select from.",11,null],[12,"debug_id","","A debug id to track down the rule generating an error.",11,null],[3,"SeparateBy","","Stores inforamtion about separated by.",null,null],[12,"rule","","The rule to separate.",12,null],[12,"by","","The rule to separate by.",12,null],[12,"optional","","Whether the rule must occur at least once.",12,null],[12,"allow_trail","","Whether the rule can end with separator.",12,null],[12,"debug_id","","A debug id to track down the rule generating an error.",12,null],[3,"Sequence","","Stores information about sequence.",null,null],[12,"args","","The sequential rules.",13,null],[12,"debug_id","","A debug id to track down the rule generating an error.",13,null],[3,"Text","","Stores information about text.",null,null],[12,"allow_empty","","Whether to allow empty string.",14,null],[12,"property","","Which property to set if text is read.",14,null],[12,"debug_id","","A debug id to track down the rule generating an error.",14,null],[3,"Tag","","Stores information about tag.",null,null],[12,"text","","The text to match against.",15,null],[12,"not","","Whether to fail when matching against text.",15,null],[12,"inverted","","Whether to set property to true or false (inverted).",15,null],[12,"property","","Which property to set if tag matches.",15,null],[12,"debug_id","","A debug id to track down the rule generating an error.",15,null],[3,"UntilAny","","Stores information about reading until whitespace or any of some character.",null,null],[12,"any_characters","","The characters to stop at.",16,null],[12,"optional","","Whether empty data is accepted or not.",16,null],[12,"property","","The property to store read text.",16,null],[12,"debug_id","","A debug id to track down the rule generating an error.",16,null],[3,"UntilAnyOrWhitespace","","Stores information about reading until whitespace or any of some character.",null,null],[12,"any_characters","","The characters to stop at.",17,null],[12,"optional","","Whether empty data is accepted or not.",17,null],[12,"property","","The property to store read text.",17,null],[12,"debug_id","","A debug id to track down the rule generating an error.",17,null],[3,"Whitespace","","Stores information about whitespace.",null,null],[12,"optional","","Whether the whitespace is optional or required.",18,null],[12,"debug_id","","A debug id to track down the rule generating an error.",18,null],[4,"Rule","","A rule describes how some section of a document should be parsed.",null,null],[13,"Whitespace","","Read whitespace.",2,null],[13,"Tag","","Match against a tag.",2,null],[13,"UntilAny","","Reads until any character.",2,null],[13,"UntilAnyOrWhitespace","","Read until any character or whitespace.",2,null],[13,"Text","","Read text.",2,null],[13,"Number","","Read number.",2,null],[13,"Select","","Select one of the sub rules. If the first one does not succeed, try another and so on. If all sub rules fail, then the rule fails.",2,null],[13,"Sequence","","Run each sub rule in sequence. If any sub rule fails, the rule fails.",2,null],[13,"SeparateBy","","Repeat rule separated by another rule.",2,null],[13,"Repeat","","Repeat rule.",2,null],[13,"Lines","","Repeat rule separated by one or more lines.",2,null],[13,"Node","","Read node.",2,null],[13,"Optional","","Read optional.",2,null],[13,"Not","","Read not.",2,null],[5,"parse","","Parses text with rules.",null,{"inputs":[{"name":"syntax"},{"name":"str"},{"name":"vec"}],"output":{"name":"result"}}],[5,"parse_errstr","","Parses text with rules, formatting the error as a `String`.",null,{"inputs":[{"name":"syntax"},{"name":"str"},{"name":"vec"}],"output":{"name":"result"}}],[5,"update_refs","","Updates the references such that they point to each other.",null,{"inputs":[{"name":"syntax"}],"output":null}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"lines"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"lines"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"lines"}],"output":{"name":"bool"}}],[11,"parse","","Parses rule separated by one or more lines. Ignores lines that only contain whitespace characters.",5,null],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"node"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"node"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"node"}],"output":{"name":"bool"}}],[11,"parse","","Parses node.",6,null],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"not"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"not"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"self"},{"name":"not"}],"output":{"name":"bool"}}],[11,"parse","","Parse not. Fails if sub rule succeeds.",7,null],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"number"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",8,{"inputs":[{"name":"self"},{"name":"number"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"self"},{"name":"number"}],"output":{"name":"bool"}}],[11,"parse","","Parses number.",8,{"inputs":[{"name":"self"},{"name":"vec"},{"name":"tokenizerstate"},{"name":"readtoken"}],"output":{"name":"parseresult"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"optional"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"optional"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"self"},{"name":"optional"}],"output":{"name":"bool"}}],[11,"parse","","Parse optional. Returns the old state if any sub rule fails.",9,null],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"repeat"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"repeat"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"repeat"}],"output":{"name":"bool"}}],[11,"parse","","Parses rule repeatedly.",10,null],[11,"clone","piston_meta","",2,{"inputs":[{"name":"self"}],"output":{"name":"rule"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"rule"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"rule"}],"output":{"name":"bool"}}],[11,"parse","","Parses rule.",2,null],[11,"update_refs","","Updates replacing names with the references.",2,null],[11,"clone","piston_meta::meta_rules","",11,{"inputs":[{"name":"self"}],"output":{"name":"select"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"select"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"self"},{"name":"select"}],"output":{"name":"bool"}}],[11,"parse","","Parses select.",11,null],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"separateby"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"separateby"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"self"},{"name":"separateby"}],"output":{"name":"bool"}}],[11,"parse","","Parses rule repeatedly separated by another rule.",12,null],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"sequence"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"sequence"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"self"},{"name":"sequence"}],"output":{"name":"bool"}}],[11,"parse","","Parses sequence. Fails if any sub rule fails.",13,null],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"text"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"text"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"self"},{"name":"text"}],"output":{"name":"bool"}}],[11,"parse","","Parses text.",14,{"inputs":[{"name":"self"},{"name":"vec"},{"name":"tokenizerstate"},{"name":"readtoken"}],"output":{"name":"parseresult"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"tag"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"tag"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"self"},{"name":"tag"}],"output":{"name":"bool"}}],[11,"parse","","Parses tag. If the tag is linked to a property, the property will be set. If the meta reader fails setting the property the error is handled. If the token is not linked to any property, the same state will be returned.",15,{"inputs":[{"name":"self"},{"name":"vec"},{"name":"tokenizerstate"},{"name":"readtoken"}],"output":{"name":"parseresult"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"untilany"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"untilany"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"untilany"}],"output":{"name":"bool"}}],[11,"parse","","Parses until whitespace or any specified characters.",16,{"inputs":[{"name":"self"},{"name":"vec"},{"name":"tokenizerstate"},{"name":"readtoken"}],"output":{"name":"parseresult"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"untilanyorwhitespace"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"untilanyorwhitespace"}],"output":{"name":"bool"}}],[11,"ne","","",17,{"inputs":[{"name":"self"},{"name":"untilanyorwhitespace"}],"output":{"name":"bool"}}],[11,"parse","","Parses until whitespace or any specified characters.",17,{"inputs":[{"name":"self"},{"name":"vec"},{"name":"tokenizerstate"},{"name":"readtoken"}],"output":{"name":"parseresult"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"whitespace"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",18,{"inputs":[{"name":"self"},{"name":"whitespace"}],"output":{"name":"bool"}}],[11,"ne","","",18,{"inputs":[{"name":"self"},{"name":"whitespace"}],"output":{"name":"bool"}}],[11,"parse","","Parse whitespace. If whitespace is required and no whitespace is found, an error will be reported.",18,{"inputs":[{"name":"self"},{"name":"readtoken"}],"output":{"name":"result"}}],[6,"ParseResult","","A parse result succeeds with a new state, plus an optional error to replace other errors if it is deeper. The deepest error is likely the most useful.",null,null],[0,"tokenizer","piston_meta","Tracking tokenizer state.",null,null],[3,"TokenizerState","piston_meta::tokenizer","Stores the number of tokens received.",null,null],[12,"0","","",19,null],[5,"read_data","","Reads meta data.",null,{"inputs":[{"name":"vec"},{"name":"range"},{"name":"tokenizerstate"}],"output":{"name":"tokenizerstate"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"tokenizerstate"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",19,{"inputs":[{"name":"self"},{"name":"tokenizerstate"}],"output":{"name":"option"}}],[11,"lt","","",19,{"inputs":[{"name":"self"},{"name":"tokenizerstate"}],"output":{"name":"bool"}}],[11,"le","","",19,{"inputs":[{"name":"self"},{"name":"tokenizerstate"}],"output":{"name":"bool"}}],[11,"gt","","",19,{"inputs":[{"name":"self"},{"name":"tokenizerstate"}],"output":{"name":"bool"}}],[11,"ge","","",19,{"inputs":[{"name":"self"},{"name":"tokenizerstate"}],"output":{"name":"bool"}}],[11,"cmp","","",19,{"inputs":[{"name":"self"},{"name":"tokenizerstate"}],"output":{"name":"ordering"}}],[11,"eq","","",19,{"inputs":[{"name":"self"},{"name":"tokenizerstate"}],"output":{"name":"bool"}}],[11,"ne","","",19,{"inputs":[{"name":"self"},{"name":"tokenizerstate"}],"output":{"name":"bool"}}],[11,"new","","Creates a new tokenizer state.",19,{"inputs":[],"output":{"name":"tokenizerstate"}}],[11,"fmt","piston_meta","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"parseerror"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"parseerror"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new error handler.",20,{"inputs":[{"name":"str"}],"output":{"name":"parseerrorhandler"}}],[11,"write_msg","","Writes message.",20,{"inputs":[{"name":"self"},{"name":"w"},{"name":"range"},{"name":"str"}],"output":{"name":"result"}}],[11,"write","","Writes error message.",20,{"inputs":[{"name":"self"},{"name":"w"},{"name":"range"}],"output":{"name":"result"}}],[11,"error","","Prints error message to standard error.",20,{"inputs":[{"name":"self"},{"name":"range"}],"output":null}],[6,"DebugId","","The type of debug id used to track down errors in rules.",null,null],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"metadata"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"metadata"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"metadata"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"syntax"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"syntax"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"syntax"}],"output":{"name":"bool"}}],[11,"new","","Creates a new syntax.",0,{"inputs":[],"output":{"name":"syntax"}}],[11,"push","","Adds a new rule.",0,{"inputs":[{"name":"self"},{"name":"arc"},{"name":"rule"}],"output":null}]],"paths":[[3,"Syntax"],[4,"ParseError"],[4,"Rule"],[4,"MetaData"],[3,"Convert"],[3,"Lines"],[3,"Node"],[3,"Not"],[3,"Number"],[3,"Optional"],[3,"Repeat"],[3,"Select"],[3,"SeparateBy"],[3,"Sequence"],[3,"Text"],[3,"Tag"],[3,"UntilAny"],[3,"UntilAnyOrWhitespace"],[3,"Whitespace"],[3,"TokenizerState"],[3,"ParseErrorHandler"]]};
searchIndex["range"] = {"doc":"A library for range addressing","items":[[3,"Range","range","A representation of a range",null,null],[12,"offset","","The range offset",0,null],[12,"length","","The range length",0,null],[12,"data","","The data described within the range.",0,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"bool"}}],[11,"hash","","",0,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `Range`",0,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"range"}}],[11,"wrap","","Wraps some data in the range.",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"range"}}],[11,"empty","","Creates an empty range with an offset.",0,{"inputs":[{"name":"usize"}],"output":{"name":"range"}}],[11,"shrink_n","","Shrinks range at both ends with `n` items.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"shrink","","Shrinks range at both ends with 1 item.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"intersect","","Intersects a range with another, where ends are excluded.",0,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"option"}}],[11,"ends_intersect","","Intersects a range with another, where ends are included.",0,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"option"}}],[11,"is_empty","","Returns true if range is empty",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"next_offset","","Returns the next offset",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"iter","","Returns a range iterator.",0,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"map","","Maps from some data to another.",0,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"range"}}],[11,"range","","Returns range information without the data.",0,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"unwrap","","Unwraps the data.",0,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"decouple","","Decouples range and data.",0,null],[11,"from","","",0,null]],"paths":[[3,"Range"]]};
searchIndex["read_token"] = {"doc":"A simple library to read tokens using look ahead","items":[[3,"ReadToken","read_token","Stores the state of parsing.",null,null],[12,"src","","Source.",0,null],[12,"offset","","Character offset.",0,null],[3,"NumberSettings","","The settings for reading numbers.",null,null],[12,"allow_underscore","","Whether to allow underscore in number.",1,null],[4,"ParseStringError","","Contains errors when parsing a string.",null,null],[13,"ExpectedFourHexadecimals","","Expected four hexadecimals, found less characters",2,null],[13,"ExpectedHexadecimal","","Expected character `0-9a-fA-F`",2,null],[13,"ExpectedValidUnicode","","Found four hexadecimals, but not an invalid unicode character",2,null],[13,"ExpectedValidEscapeCharacter","","A character escape `\\x` is invalid",2,null],[4,"ParseNumberError","","Error when parsing number.",null,null],[13,"ExpectedDigits","","The number was empty.",3,null],[13,"Invalid","","The number is of invalid format.",3,null],[13,"OverflowInfinity","","The number overflowed to infinity.",3,null],[13,"OverflowNegInfinity","","The number overflowed to negative infinity.",3,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"readtoken"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `ReadToken`. The offset is in characters.",0,{"inputs":[{"name":"str"},{"name":"usize"}],"output":{"name":"readtoken"}}],[11,"consume","","Consumes n characters.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"readtoken"}}],[11,"raw_string","","Reads a raw string.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"string"}}],[11,"lines","","Read lines until closure returns `None`. Returns `Ok(range)` of the successful read lines. Returns `Err(range)` when expected new line.",0,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"subtract","","Returns the difference in offset.",0,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"range"}}],[11,"start","","Returns an empty range at current offset.",0,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"peek","","Peek a number of characters ahead.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"range"}}],[11,"tag","","Reads an expected tag, returns character range and new state. Returns old state when fail to match tag.",0,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"until_any_or_whitespace","","Reads a token until any character in string or whitespace. Returns `(range, None)` if stopping at whitespace or end of characters. Returns `(range, Some(x))` if stopping at a character.",0,null],[11,"until_any","","Reads token until any character in string. Returns `(new_state, range, None)` if stopping at end of characters. Returns `(new_state, range, Some(x))` if stopping at a character.",0,null],[11,"whitespace","","Reads whitespace.",0,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"string","","Reads string with character escapes.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"number","","Reads number.",0,{"inputs":[{"name":"self"},{"name":"numbersettings"}],"output":{"name":"option"}}],[11,"parse_string","","Parses string into a real string according to the JSON standard.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"result"}}],[11,"parse_number","","Parses number from n characters.",0,{"inputs":[{"name":"self"},{"name":"numbersettings"},{"name":"usize"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"parsestringerror"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"parsestringerror"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"numbersettings"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"parsenumbererror"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"parsenumbererror"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[3,"ReadToken"],[3,"NumberSettings"],[4,"ParseStringError"],[4,"ParseNumberError"]]};
initSearch(searchIndex);
