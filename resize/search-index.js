var searchIndex = JSON.parse('{\
"bytemuck":{"doc":"This crate gives small utilities for casting between plain…","i":[[4,"PodCastError","bytemuck","The things that can go wrong when casting between [`Pod`]…",null,null],[13,"TargetAlignmentGreaterAndInputNotAligned","","You tried to cast a slice to an element type with a higher…",0,null],[13,"OutputSliceWouldHaveSlop","","If the element size changes then the output slice changes…",0,null],[13,"SizeMismatch","","When casting a slice you can\'t convert between ZST…",0,null],[13,"AlignmentMismatch","","For this type of cast the alignments must be exactly the…",0,null],[5,"bytes_of","","Re-interprets `&T` as `&[u8]`.",null,[[]]],[5,"bytes_of_mut","","Re-interprets `&mut T` as `&mut [u8]`.",null,[[]]],[5,"from_bytes","","Re-interprets `&[u8]` as `&T`.",null,[[]]],[5,"from_bytes_mut","","Re-interprets `&mut [u8]` as `&mut T`.",null,[[]]],[5,"try_from_bytes","","Re-interprets `&[u8]` as `&T`.",null,[[],[["result",4],["podcasterror",4]]]],[5,"try_from_bytes_mut","","Re-interprets `&mut [u8]` as `&mut T`.",null,[[],[["result",4],["podcasterror",4]]]],[5,"cast","","Cast `T` into `U`",null,[[["pod",8]],["pod",8]]],[5,"cast_mut","","Cast `&mut T` into `&mut U`.",null,[[]]],[5,"cast_ref","","Cast `&T` into `&U`.",null,[[]]],[5,"cast_slice","","Cast `&[T]` into `&[U]`.",null,[[]]],[5,"cast_slice_mut","","Cast `&mut [T]` into `&mut [U]`.",null,[[]]],[5,"pod_align_to","","As `align_to`, but safe because of the [`Pod`] bound.",null,[[]]],[5,"pod_align_to_mut","","As `align_to_mut`, but safe because of the [`Pod`] bound.",null,[[]]],[5,"try_cast","","Try to cast `T` into `U`.",null,[[["pod",8]],[["podcasterror",4],["result",4],["pod",8]]]],[5,"try_cast_ref","","Try to convert a `&T` into `&U`.",null,[[],[["podcasterror",4],["result",4]]]],[5,"try_cast_mut","","Try to convert a `&mut T` into `&mut U`.",null,[[],[["result",4],["podcasterror",4]]]],[5,"try_cast_slice","","Try to convert `&[T]` into `&[U]` (possibly with a change…",null,[[],[["podcasterror",4],["result",4]]]],[5,"try_cast_slice_mut","","Try to convert `&mut [T]` into `&mut [U]` (possibly with a…",null,[[],[["result",4],["podcasterror",4]]]],[8,"Zeroable","","Trait for types that can be safely created with `zeroed`.",null,null],[11,"zeroed","","Calls `zeroed`.",1,[[]]],[8,"Pod","","Marker trait for \\\"plain old data\\\".",null,null],[8,"Contiguous","","A trait indicating that:",null,null],[16,"Int","","The primitive integer type with an identical…",2,null],[18,"MAX_VALUE","","The upper inclusive bound for valid instances of this type.",2,null],[18,"MIN_VALUE","","The lower inclusive bound for valid instances of this type.",2,null],[11,"from_integer","","If `value` is within the range for valid instances of this…",2,[[],["option",4]]],[11,"into_integer","","Perform the conversion from `C` into the underlying…",2,[[]]],[8,"TransparentWrapper","","A trait which indicates that a type is a…",null,null],[11,"wrap_ref","","Convert a reference to a wrapped type into a reference to…",3,[[]]],[11,"wrap_mut","","Convert a mut reference to a wrapped type into a mut…",3,[[]]],[14,"offset_of","","Find the offset in bytes of the given `$field` of `$Type`.…",null,null],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"eq","","",0,[[["podcasterror",4]]]],[11,"hash","","",0,[[]]],[11,"clone","","",0,[[],["podcasterror",4]]],[11,"zeroed","","Calls `zeroed`.",1,[[]]],[18,"MAX_VALUE","","The upper inclusive bound for valid instances of this type.",2,null],[18,"MIN_VALUE","","The lower inclusive bound for valid instances of this type.",2,null],[11,"from_integer","","If `value` is within the range for valid instances of this…",2,[[],["option",4]]],[11,"into_integer","","Perform the conversion from `C` into the underlying…",2,[[]]],[11,"wrap_ref","","Convert a reference to a wrapped type into a reference to…",3,[[]]],[11,"wrap_mut","","Convert a mut reference to a wrapped type into a mut…",3,[[]]]],"p":[[4,"PodCastError"],[8,"Zeroable"],[8,"Contiguous"],[8,"TransparentWrapper"]]},\
"resize":{"doc":"Simple resampling library in pure Rust.","i":[[3,"Filter","resize","Resampling filter.",null,null],[3,"Resizer","","Resampler with preallocated buffers and coeffecients for…",null,null],[4,"Type","","Resizing type to use.",null,null],[13,"Point","","Point resizing.",0,null],[13,"Triangle","","Triangle (bilinear) resizing.",0,null],[13,"Catrom","","Catmull-Rom (bicubic) resizing.",0,null],[13,"Mitchell","","Resize using Mitchell-Netravali filter.",0,null],[13,"Lanczos3","","Resize using Sinc-windowed Sinc with radius of 3.",0,null],[13,"Custom","","Resize with custom filter.",0,null],[5,"new","","Create a new resizer instance. Alias for `Resizer::new`.",null,[[["pixelformat",8],["type",4]],[["pixelformat",8],["resizer",3]]]],[5,"resize","","Use `new().resize()` instead.",null,[[["type",4],["pixelformatbackcompatshim",8]]]],[0,"Pixel","","Supported pixel formats.",null,null],[17,"Gray8","resize::Pixel","Grayscale, 8-bit.",null,null],[17,"Gray16","","Grayscale, 16-bit, native endian.",null,null],[17,"GrayF32","","Grayscale, 32-bit float",null,null],[17,"GrayF64","","Grayscale, 64-bit float",null,null],[17,"RGB24","","RGB, 8-bit per component.",null,null],[17,"RGB48","","RGB, 16-bit per component, native endian.",null,null],[17,"RGBA","","RGBA, 8-bit per component.",null,null],[17,"RGBA64","","RGBA, 16-bit per component, native endian.",null,null],[17,"RGBF32","","RGB, 32-bit float per component. This is pretty efficient,…",null,null],[17,"RGBF64","","RGB, 64-bit double per component.",null,null],[17,"RGBAF32","","RGBA, 32-bit float per component. This is pretty…",null,null],[17,"RGBAF64","","RGBA, 64-bit double per component.",null,null],[8,"PixelFormat","resize","Use `Pixel` presets to specify pixel format.",null,null],[16,"InputPixel","","Pixel type in the source image",1,null],[16,"OutputPixel","","Pixel type in the destination image (usually the same as…",1,null],[16,"Accumulator","","Temporary struct for the pixel in floating-point",1,null],[10,"new","","Create new floating-point pixel",1,[[]]],[10,"add","","Add new pixel with a given weight (first axis)",1,[[]]],[10,"add_acc","","Add bunch of accumulated pixels with a weight (second axis)",1,[[]]],[10,"into_pixel","","Finalize, convert to output pixel format",1,[[]]],[11,"new","","Create a new filter.",2,[[["fn",8],["box",3]]]],[11,"new_cubic","","Helper to create Cubic filter with custom B and C…",2,[[]]],[11,"new_lanczos","","Helper to create Lanczos filter with custom radius.",2,[[]]],[11,"new","","Create a new resizer instance.",3,[[["type",4]]]],[11,"resize","","Resize `src` image data into `dst`.",3,[[]]],[11,"resize_stride","","Resize `src` image data into `dst`, skipping `stride`…",3,[[]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]]],"p":[[4,"Type"],[8,"PixelFormat"],[3,"Filter"],[3,"Resizer"]]},\
"rgb":{"doc":"Basic struct for `RGB` and `RGBA` pixels. Packed, with red…","i":[[8,"Pod","rgb","Re-export from `bytemuck` crate Marker trait for \\\"plain…",null,null],[8,"Zeroable","","Re-export from `bytemuck` crate Trait for types that can…",null,null],[11,"zeroed","","Calls `zeroed`.",0,[[]]],[3,"RGB","","The RGB pixel",null,null],[12,"r","","Red",1,null],[12,"g","","Green",1,null],[12,"b","","Blue",1,null],[3,"RGBA","","The RGBA pixel",null,null],[12,"r","","Red",2,null],[12,"g","","Green",2,null],[12,"b","","Blue",2,null],[12,"a","","Alpha",2,null],[11,"new","","Convenience function for creating a new pixel The order of…",1,[[]]],[11,"iter","","Iterate over color components (R, G, and B)",1,[[],[["cloned",3],["iter",3]]]],[11,"alpha","","Convenience function for converting to RGBA",1,[[],["rgba",3]]],[11,"new_alpha","","Convenience function for converting to RGBA with alpha…",1,[[],["rgba",3]]],[11,"new","","Convenience function for creating a new pixel The order of…",2,[[]]],[11,"new_alpha","","Convenience function for creating a new pixel The order of…",2,[[]]],[11,"rgb_mut","","Provide a mutable view of only RGB components (leaving out…",2,[[],["rgb",3]]],[11,"rgb","","Copy RGB components out of the RGBA struct",2,[[],["rgb",3]]],[11,"iter","","Iterate over all components (length=4)",2,[[],[["cloned",3],["iter",3]]]],[11,"bgr","","Copy RGB components out of the RGBA struct",2,[[],["bgr",3]]],[11,"map_rgb","","Create new RGBA with the same alpha value, but different…",2,[[],["rgba",3]]],[11,"alpha","","Create a new RGBA with the new alpha value, but same RGB…",2,[[]]],[11,"map_alpha","","Create a new RGBA with a new alpha value created by the…",2,[[],["rgba",3]]],[0,"alt","","BGR/BGRA alernative layouts & grayscale",null,null],[3,"BGR","rgb::alt","RGB in reverse byte order",null,null],[12,"b","","Blue first",3,null],[12,"g","","Green",3,null],[12,"r","","Red last",3,null],[3,"BGRA","","BGR+A",null,null],[12,"b","","Blue first",4,null],[12,"g","","Green",4,null],[12,"r","","Red",4,null],[12,"a","","Alpha last",4,null],[3,"Gray","","Grayscale. Use `.0` or `*` (deref) to access the value.",null,null],[12,"0","","brightness level",5,null],[3,"GrayAlpha","","Grayscale with alpha. Use `.0`/`.1` to access.",null,null],[12,"0","","brightness level",6,null],[12,"1","","alpha",6,null],[6,"BGR8","","8-bit BGR",null,null],[6,"BGR16","","16-bit BGR in machine\'s native endian",null,null],[6,"BGRA8","","8-bit BGRA",null,null],[6,"BGRA16","","16-bit BGR in machine\'s native endian",null,null],[6,"GRAY8","","8-bit gray",null,null],[6,"GRAY16","","16-bit gray in machine\'s native endian",null,null],[6,"GRAYA8","","8-bit gray with alpha in machine\'s native endian",null,null],[6,"GRAYA16","","16-bit gray with alpha in machine\'s native endian",null,null],[11,"new","","New grayscale pixel",5,[[]]],[11,"gray","","Copy `Gray` component out of the `GrayAlpha` struct",6,[[],["gray",3]]],[11,"new","","New grayscale+alpha pixel",6,[[]]],[11,"gray_mut","","Provide a mutable view of only `Gray` component (leaving…",6,[[],["gray",3]]],[11,"alpha","","Create a new `GrayAlpha` with the new alpha value, but…",6,[[]]],[11,"map_alpha","","Create a new `GrayAlpha` with a new alpha value created by…",6,[[],["grayalpha",3]]],[11,"map_gray","","Create new `GrayAlpha` with the same alpha value, but…",6,[[],["grayalpha",3]]],[6,"RGB8","rgb","8-bit RGB",null,null],[6,"RGB16","","16-bit RGB in machine\'s native endian",null,null],[6,"RGBA8","","8-bit RGBA, alpha is last. 0 = transparent, 255 = opaque.",null,null],[6,"RGBA16","","16-bit RGB in machine\'s native endian. 0 = transparent,…",null,null],[8,"AsPixels","","Casts a slice of bytes into a slice of pixels, e.g. `[u8]`…",null,null],[10,"as_pixels","","Reinterpret the slice as a read-only/shared slice of…",7,[[]]],[10,"as_pixels_mut","","Reinterpret the slice as a mutable/exclusive slice of…",7,[[]]],[8,"FromSlice","","Cast a slice of component values (bytes) as a slice of…",null,null],[10,"as_rgb","","Reinterpert slice as RGB pixels",8,[[]]],[10,"as_rgba","","Reinterpert slice as RGBA pixels",8,[[]]],[10,"as_rgb_mut","","Reinterpert mutable slice as RGB pixels",8,[[]]],[10,"as_rgba_mut","","Reinterpert mutable slice as RGBA pixels",8,[[]]],[10,"as_gray","","Reinterpert mutable slice as grayscale pixels",8,[[]]],[10,"as_gray_alpha","","Reinterpert mutable slice as grayscale pixels with alpha",8,[[]]],[10,"as_gray_mut","","Reinterpert mutable slice as grayscale pixels",8,[[]]],[10,"as_gray_alpha_mut","","Reinterpert mutable slice as grayscale pixels with alpha",8,[[]]],[10,"as_bgr","","Reinterpert slice as reverse-order BGR pixels",8,[[]]],[10,"as_bgra","","Reinterpert slice as reverse-order BGRA pixels",8,[[]]],[10,"as_bgr_mut","","Reinterpert ntable slice as reverse-order BGR pixels",8,[[]]],[10,"as_bgra_mut","","Reinterpert mutable slice as reverse-order BGRA pixels",8,[[]]],[8,"ComponentSlice","","Casting the struct to slices of its components",null,null],[10,"as_slice","","The components interpreted as an array, e.g. one `RGB`…",9,[[]]],[10,"as_mut_slice","","The components interpreted as a mutable array, e.g. one…",9,[[]]],[8,"ComponentBytes","","Casting a slice of `RGB/A` values to a slice of `u8`",null,null],[11,"as_bytes","","The components interpreted as raw bytes, in machine\'s…",10,[[]]],[11,"as_bytes_mut","","The components interpreted as raw bytes, in machine\'s…",10,[[]]],[8,"ComponentMap","","Applying operation to every component",null,null],[10,"map","","Convenience function (equivalent of…",11,[[]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","rgb::alt","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"from","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"as_slice","rgb","",1,[[]]],[11,"as_mut_slice","","",1,[[]]],[11,"as_slice","rgb::alt","",3,[[]]],[11,"as_mut_slice","","",3,[[]]],[11,"as_slice","rgb","",2,[[]]],[11,"as_mut_slice","","",2,[[]]],[11,"as_slice","rgb::alt","",4,[[]]],[11,"as_mut_slice","","",4,[[]]],[11,"as_slice","","",6,[[]]],[11,"as_mut_slice","","",6,[[]]],[11,"as_slice","","",5,[[]]],[11,"as_mut_slice","","",5,[[]]],[11,"map","rgb","",1,[[],["rgb",3]]],[11,"map","rgb::alt","",3,[[],["bgr",3]]],[11,"map","rgb","",2,[[],["rgba",3]]],[11,"map","rgb::alt","",4,[[],["bgra",3]]],[11,"map","","",5,[[],["gray",3]]],[11,"map","","",6,[[],["grayalpha",3]]],[11,"deref","","",5,[[]]],[11,"from","rgb","",1,[[]]],[11,"from","","",2,[[]]],[11,"from","rgb::alt","",3,[[]]],[11,"from","","",4,[[]]],[11,"from","rgb","",1,[[]]],[11,"from","","",2,[[]]],[11,"from","rgb::alt","",3,[[]]],[11,"from","","",4,[[]]],[11,"from","rgb","",1,[[["rgb",3]]]],[11,"from","","",1,[[["rgb",3]]]],[11,"from","","",1,[[["rgb",3]]]],[11,"from","","",1,[[["rgb",3]]]],[11,"from","","",1,[[["rgb",3]]]],[11,"from","","",1,[[["rgb",3]]]],[11,"from","","",1,[[["rgb",3]]]],[11,"from","","",1,[[["rgb",3]]]],[11,"from","","",1,[[["rgb",3]]]],[11,"from","","",1,[[["rgb",3]]]],[11,"from","","",2,[[["rgba",3]]]],[11,"from","","",2,[[["rgba",3]]]],[11,"from","","",2,[[["rgba",3]]]],[11,"from","","",2,[[["rgba",3]]]],[11,"from","","",2,[[["rgba",3]]]],[11,"from","","",2,[[["rgba",3]]]],[11,"from","","",2,[[["rgba",3]]]],[11,"from","","",2,[[["rgba",3]]]],[11,"from","","",2,[[["rgba",3]]]],[11,"from","","",1,[[["gray",3]]]],[11,"from","","",2,[[["grayalpha",3]]]],[11,"from","rgb::alt","",3,[[["rgb",3]]]],[11,"from","","",4,[[["rgba",3]]]],[11,"from","rgb","",1,[[["bgr",3]]]],[11,"from","","",2,[[["bgra",3]]]],[11,"from","rgb::alt","",4,[[["bgr",3]]]],[11,"from","","",4,[[["bgr",3]]]],[11,"from","","",4,[[["rgb",3]]]],[11,"from","","",4,[[["rgb",3]]]],[11,"from","rgb","",2,[[["bgr",3]]]],[11,"from","","",2,[[["bgr",3]]]],[11,"from","","",2,[[["rgb",3]]]],[11,"from","","",2,[[["rgb",3]]]],[11,"from","rgb::alt","",5,[[]]],[11,"from","","",6,[[["gray",3]]]],[11,"from","","",6,[[["gray",3]]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","rgb","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","rgb::alt","",3,[[["formatter",3]],["result",6]]],[11,"fmt","rgb","",2,[[["formatter",3]],["result",6]]],[11,"fmt","rgb::alt","",4,[[["formatter",3]],["result",6]]],[11,"div","rgb","",1,[[]]],[11,"div","","",2,[[]]],[11,"div","rgb::alt","",5,[[]]],[11,"div","","",6,[[]]],[11,"sub","rgb","",1,[[]]],[11,"sub","","",2,[[]]],[11,"sub","rgb::alt","",5,[[]]],[11,"sub","","",6,[[]]],[11,"sub","rgb","",1,[[["rgb",3]]]],[11,"sub","rgb::alt","",5,[[["gray",3]]]],[11,"sub","rgb","",2,[[["rgba",3]]]],[11,"sub","rgb::alt","",6,[[["grayalpha",3]]]],[11,"eq","","",3,[[["bgr",3]]]],[11,"ne","","",3,[[["bgr",3]]]],[11,"eq","","",4,[[["bgra",3]]]],[11,"ne","","",4,[[["bgra",3]]]],[11,"eq","","",5,[[["gray",3]]]],[11,"ne","","",5,[[["gray",3]]]],[11,"eq","","",6,[[["grayalpha",3]]]],[11,"ne","","",6,[[["grayalpha",3]]]],[11,"eq","rgb","",1,[[["rgb",3]]]],[11,"ne","","",1,[[["rgb",3]]]],[11,"eq","","",2,[[["rgba",3]]]],[11,"ne","","",2,[[["rgba",3]]]],[11,"cmp","rgb::alt","",3,[[["bgr",3]],["ordering",4]]],[11,"cmp","","",4,[[["bgra",3]],["ordering",4]]],[11,"cmp","","",5,[[["gray",3]],["ordering",4]]],[11,"cmp","","",6,[[["grayalpha",3]],["ordering",4]]],[11,"cmp","rgb","",1,[[["rgb",3]],["ordering",4]]],[11,"cmp","","",2,[[["rgba",3]],["ordering",4]]],[11,"partial_cmp","rgb::alt","",3,[[["bgr",3]],[["ordering",4],["option",4]]]],[11,"lt","","",3,[[["bgr",3]]]],[11,"le","","",3,[[["bgr",3]]]],[11,"gt","","",3,[[["bgr",3]]]],[11,"ge","","",3,[[["bgr",3]]]],[11,"partial_cmp","","",4,[[["bgra",3]],[["ordering",4],["option",4]]]],[11,"lt","","",4,[[["bgra",3]]]],[11,"le","","",4,[[["bgra",3]]]],[11,"gt","","",4,[[["bgra",3]]]],[11,"ge","","",4,[[["bgra",3]]]],[11,"partial_cmp","","",5,[[["gray",3]],[["ordering",4],["option",4]]]],[11,"lt","","",5,[[["gray",3]]]],[11,"le","","",5,[[["gray",3]]]],[11,"gt","","",5,[[["gray",3]]]],[11,"ge","","",5,[[["gray",3]]]],[11,"partial_cmp","","",6,[[["grayalpha",3]],[["ordering",4],["option",4]]]],[11,"lt","","",6,[[["grayalpha",3]]]],[11,"le","","",6,[[["grayalpha",3]]]],[11,"gt","","",6,[[["grayalpha",3]]]],[11,"ge","","",6,[[["grayalpha",3]]]],[11,"partial_cmp","rgb","",1,[[["rgb",3]],[["ordering",4],["option",4]]]],[11,"lt","","",1,[[["rgb",3]]]],[11,"le","","",1,[[["rgb",3]]]],[11,"gt","","",1,[[["rgb",3]]]],[11,"ge","","",1,[[["rgb",3]]]],[11,"partial_cmp","","",2,[[["rgba",3]],[["ordering",4],["option",4]]]],[11,"lt","","",2,[[["rgba",3]]]],[11,"le","","",2,[[["rgba",3]]]],[11,"gt","","",2,[[["rgba",3]]]],[11,"ge","","",2,[[["rgba",3]]]],[11,"add","","",1,[[]]],[11,"add","","",2,[[]]],[11,"add","rgb::alt","",5,[[]]],[11,"add","","",6,[[]]],[11,"add","rgb","",1,[[["rgb",3]]]],[11,"add","rgb::alt","",5,[[["gray",3]]]],[11,"add","rgb","",2,[[["rgba",3]]]],[11,"add","rgb::alt","",6,[[["grayalpha",3]]]],[11,"mul","rgb","",1,[[]]],[11,"mul","","",2,[[]]],[11,"mul","rgb::alt","",5,[[]]],[11,"mul","","",6,[[]]],[11,"add_assign","rgb","",1,[[]]],[11,"add_assign","","",2,[[]]],[11,"add_assign","rgb::alt","",5,[[]]],[11,"add_assign","","",6,[[]]],[11,"add_assign","rgb","",1,[[["rgb",3]]]],[11,"add_assign","rgb::alt","",5,[[["gray",3]]]],[11,"add_assign","rgb","",2,[[["rgba",3]]]],[11,"add_assign","rgb::alt","",6,[[["grayalpha",3]]]],[11,"sub_assign","rgb","",1,[[]]],[11,"sub_assign","","",2,[[]]],[11,"sub_assign","rgb::alt","",5,[[]]],[11,"sub_assign","","",6,[[]]],[11,"sub_assign","rgb","",1,[[["rgb",3]]]],[11,"sub_assign","rgb::alt","",5,[[["gray",3]]]],[11,"sub_assign","rgb","",2,[[["rgba",3]]]],[11,"sub_assign","rgb::alt","",6,[[["grayalpha",3]]]],[11,"mul_assign","rgb","",1,[[]]],[11,"mul_assign","","",2,[[]]],[11,"mul_assign","rgb::alt","",5,[[]]],[11,"mul_assign","","",6,[[]]],[11,"div_assign","rgb","",1,[[]]],[11,"div_assign","","",2,[[]]],[11,"div_assign","rgb::alt","",5,[[]]],[11,"div_assign","","",6,[[]]],[11,"hash","","",3,[[]]],[11,"hash","","",4,[[]]],[11,"hash","","",5,[[]]],[11,"hash","","",6,[[]]],[11,"hash","rgb","",1,[[]]],[11,"hash","","",2,[[]]],[11,"from_iter","","Takes exactly 3 elements from the iterator and creates a…",1,[[["intoiterator",8]]]],[11,"from_iter","","Takes exactly 4 elements from the iterator and creates a…",2,[[["intoiterator",8]]]],[11,"sum","","",1,[[["iterator",8]]]],[11,"sum","rgb::alt","",5,[[["iterator",8]]]],[11,"sum","rgb","",2,[[["iterator",8]]]],[11,"sum","rgb::alt","",6,[[["iterator",8]]]],[11,"as_ref","","",5,[[]]],[11,"as_ref","rgb","",1,[[]]],[11,"as_ref","","",2,[[]]],[11,"as_ref","rgb::alt","",6,[[]]],[11,"as_mut","","",5,[[]]],[11,"as_mut","rgb","",1,[[]]],[11,"as_mut","","",2,[[]]],[11,"as_mut","rgb::alt","",6,[[]]],[11,"into","rgb","",1,[[]]],[11,"into","","",2,[[]]],[11,"into","rgb::alt","",3,[[]]],[11,"into","","",4,[[]]],[11,"into","rgb","",1,[[]]],[11,"into","","",2,[[]]],[11,"into","rgb::alt","",3,[[]]],[11,"into","","",4,[[]]],[11,"fmt","rgb","",1,[[["formatter",3]],["result",6]]],[11,"fmt","rgb::alt","",3,[[["formatter",3]],["result",6]]],[11,"fmt","rgb","",1,[[["formatter",3]],["result",6]]],[11,"fmt","rgb::alt","",3,[[["formatter",3]],["result",6]]],[11,"clone","","",3,[[],["bgr",3]]],[11,"clone","","",4,[[],["bgra",3]]],[11,"clone","","",5,[[],["gray",3]]],[11,"clone","","",6,[[],["grayalpha",3]]],[11,"clone","rgb","",1,[[],["rgb",3]]],[11,"clone","","",2,[[],["rgba",3]]],[11,"default","rgb::alt","",3,[[],["bgr",3]]],[11,"default","","",4,[[],["bgra",3]]],[11,"default","","",5,[[],["gray",3]]],[11,"default","","",6,[[],["grayalpha",3]]],[11,"default","rgb","",1,[[],["rgb",3]]],[11,"default","","",2,[[],["rgba",3]]],[11,"as_bytes","","The components interpreted as raw bytes, in machine\'s…",10,[[]]],[11,"as_bytes_mut","","The components interpreted as raw bytes, in machine\'s…",10,[[]]],[11,"new","rgb::alt","Convenience function for creating a new pixel Wargning:…",3,[[]]],[11,"iter","","Iterate over color components (R, G, and B)",3,[[],[["cloned",3],["iter",3]]]],[11,"alpha","","Convenience function for converting to RGBA",3,[[],["bgra",3]]],[11,"new_alpha","","Convenience function for converting to RGBA with alpha…",3,[[],["bgra",3]]],[11,"new","","Convenience function for creating a new pixel Warning: The…",4,[[]]],[11,"new_alpha","","Convenience function for creating a new pixel Warning: The…",4,[[]]],[11,"rgb_mut","","Provide a mutable view of only RGB components (leaving out…",4,[[],["bgr",3]]],[11,"bgr_mut","","Provide a mutable view of only RGB components (leaving out…",4,[[],["bgr",3]]],[11,"rgb","","Copy RGB components out of the RGBA struct",4,[[],["bgr",3]]],[11,"iter","","Iterate over all components (length=4)",4,[[],[["cloned",3],["iter",3]]]],[11,"bgr","","Copy RGB components out of the RGBA struct",4,[[],["bgr",3]]],[11,"map_rgb","","Create new RGBA with the same alpha value, but different…",4,[[],["bgra",3]]],[11,"alpha","","Create a new RGBA with the new alpha value, but same RGB…",4,[[]]],[11,"map_alpha","","Create a new RGBA with a new alpha value created by the…",4,[[],["bgra",3]]]],"p":[[8,"Zeroable"],[3,"RGB"],[3,"RGBA"],[3,"BGR"],[3,"BGRA"],[3,"Gray"],[3,"GrayAlpha"],[8,"AsPixels"],[8,"FromSlice"],[8,"ComponentSlice"],[8,"ComponentBytes"],[8,"ComponentMap"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);