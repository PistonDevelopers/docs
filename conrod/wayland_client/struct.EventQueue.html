<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `EventQueue` struct in crate `wayland_client`."><meta name="keywords" content="rust, rustlang, rust-lang, EventQueue"><title>wayland_client::EventQueue - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Struct EventQueue</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.dispatch">dispatch</a><a href="#method.dispatch_pending">dispatch_pending</a><a href="#method.sync_roundtrip">sync_roundtrip</a><a href="#method.get_token">get_token</a><a href="#method.prepare_read">prepare_read</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a></div></div><p class='location'><a href='index.html'>wayland_client</a></p><script>window.sidebarCurrent = {name: 'EventQueue', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>wayland_client</a>::<wbr><a class="struct" href=''>EventQueue</a></span><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/wayland_client/event_queue.rs.html#49-52' title='goto source code'>[src]</a></span></h1><div class="docblock type-decl"><pre class='rust struct'>pub struct EventQueue { /* fields omitted */ }</pre></div><div class='docblock'><p>An event queue for protocol messages</p>
<p>Event dispatching in wayland is made on a queue basis, allowing you
to organise your objects into different queues that can be dispatched
independently, for example from different threads.</p>
<p>And <code>EventQueue</code> is not <code>Send</code>, and thus must stay on the thread on which
they were created. However the <code>Display</code> object is <code>Send + Sync</code>, allowing
you to create the queues directly in the threads that host them.</p>
<p>When a queue is dispatched (via the <code>dispatch()</code> or <code>dispatch_pending()</code> methods)
all the incoming messages from the server destinated to objects associated with
the queue are processed sequentially, and the appropriate implementation for each
is invoked. When all messages have been processed these methods return.</p>
<p>Thus, a typical single-queue event loop for a simple wayland app can be:</p>

<pre class="rust rust-example-rendered">
<span class="kw">loop</span> {
    <span class="ident">display</span>.<span class="ident">flush</span>().<span class="ident">unwrap</span>();
    <span class="ident">event_queue</span>.<span class="ident">dispatch</span>().<span class="ident">expect</span>(<span class="string">&quot;An error occured during event dispatching!&quot;</span>);
}</pre>
<p>See <code>EventQueue::prepare_read()</code> if you need more control about when the connection
socket is read. This will typically the case if you need to integrate other sources
of event into the event loop of your application.</p>
</div>
                    <h2 id='methods' class='small-section-header'>
                      Methods<a href='#methods' class='anchor'></a>
                    </h2>
                <h3 id='impl' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="struct" href="../wayland_client/struct.EventQueue.html" title="struct wayland_client::EventQueue">EventQueue</a></code><a href='#impl' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/wayland_client/event_queue.rs.html#64-238' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.dispatch' class="method"><span id='dispatch.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.dispatch' class='fnname'>dispatch</a>(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">IoResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/wayland_client/event_queue.rs.html#85-109' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Dispatches events from the internal buffer.</p>
<p>Dispatches all events to their appropriaters.
If no events were in the internal buffer, will block until
some events are read and dispatch them.
This process can insert events in the internal buffers of
other event queues.</p>
<p>If an error is returned, your connection with the wayland
compositor is probably lost.</p>
</div><h4 id='method.dispatch_pending' class="method"><span id='dispatch_pending.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.dispatch_pending' class='fnname'>dispatch_pending</a>(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">IoResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/wayland_client/event_queue.rs.html#119-147' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Dispatches pending events from the internal buffer.</p>
<p>Dispatches all events to their appropriaters.
Never blocks, if no events were pending, simply returns
<code>Ok(0)</code>.</p>
<p>If an error is returned, your connection with the wayland
compositor is probably lost.</p>
</div><h4 id='method.sync_roundtrip' class="method"><span id='sync_roundtrip.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.sync_roundtrip' class='fnname'>sync_roundtrip</a>(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">IoResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/wayland_client/event_queue.rs.html#158-184' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Synchronous roundtrip</p>
<p>This call will cause a synchonous roundtrip with the wayland server. It will block until all
pending requests of this queue are sent to the server and it has processed all of them and
send the appropriate events.</p>
<p>Handlers are called as a consequence.</p>
<p>On success returns the number of dispatched events.</p>
</div><h4 id='method.get_token' class="method"><span id='get_token.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.get_token' class='fnname'>get_token</a>(&amp;self) -&gt; <a class="struct" href="../wayland_client/struct.QueueToken.html" title="struct wayland_client::QueueToken">QueueToken</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/wayland_client/event_queue.rs.html#189-193' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Create a new token associated with this event queue</p>
<p>See <code>QueueToken</code> documentation for its use.</p>
</div><h4 id='method.prepare_read' class="method"><span id='prepare_read.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.prepare_read' class='fnname'>prepare_read</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../wayland_client/struct.ReadEventsGuard.html" title="struct wayland_client::ReadEventsGuard">ReadEventsGuard</a>&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/wayland_client/event_queue.rs.html#214-237' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Prepare an conccurent read</p>
<p>Will declare your intention to read events from the server socket.</p>
<p>Will return <code>None</code> if there are still some events awaiting dispatch on this EventIterator.
In this case, you need to call <code>dispatch_pending()</code> before calling this method again.</p>
<p>As long as the returned guard is in scope, no events can be dispatched to any event iterator.</p>
<p>The guard can then be destroyed by two means:</p>
<ul>
<li>Calling its <code>cancel()</code> method (or letting it go out of scope): the read intention will
be cancelled</li>
<li>Calling its <code>read_events()</code> method: will block until all existing guards are destroyed
by one of these methods, then events will be read and all blocked <code>read_events()</code> calls
will return.</li>
</ul>
<p>This call will otherwise not block on the server socket if it is empty, and return
an io error <code>WouldBlock</code> in such cases.</p>
</div></div>
                <h2 id='synthetic-implementations' class='small-section-header'>
                  Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a>
                </h2>
                <div id='synthetic-implementations-list'>
            <h3 id='impl-Send' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../wayland_client/struct.EventQueue.html" title="struct wayland_client::EventQueue">EventQueue</a></code><a href='#impl-Send' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../wayland_client/struct.EventQueue.html" title="struct wayland_client::EventQueue">EventQueue</a></code><a href='#impl-Sync' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "wayland_client";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>